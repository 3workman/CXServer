/***********************************************************************
* @ 消息池
* @ brief
    1、转接网络层buffer中的数据，缓存，以待主逻辑循环处理
    2、直接处理网络buffer的数据，那就是在IO线程做逻辑了，很可能出现性能风险

* @ Notice
    1、Insert()接口，供网络层调用，是多线程的，所以消息池必须线程安全
    2、避免野指针：队列中缓存了Player*，应在主逻辑Handle()后才做 delete player

    3、“同名rpc混乱”：client rpc server且有回包；若server那边也有个同名rpc client，那client就不好区分底层收到的包，是自己rpc的回复，还是对方主动rpc
    4、远程调用其它模块的rpc，应是本模块未声明实现的。避免同名rpc的混乱
    5、rpc底层的回包，设计成带类型的（主动发、被动回），能解决“同名rpc混乱”问题，但觉用处不大，就先免掉

* @ author zhoumf
* @ date 2016-12-12
************************************************************************/
#pragma once
#include "tool/SafeQueue.h"
#include "Buffer/NetPack.h"
#include "Csv/CSVparser.hpp"

typedef std::function<void(NetPack&)> ParseRpcParam;
typedef std::function<void(const NetPack&)> SendMsgFunc;

template <typename Typ> // 类型Typ须含有：_rpc列表，SendMsg()
class RpcQueue {
    typedef std::pair<Typ*, NetPack*> RpcPair;

    std::map<int, ParseRpcParam> _response;  //rpc远端的回复
    SafeQueue<RpcPair>          _queue; //Notice：为避免缓存指针野掉，主循环HandleMsg之后，处理登出逻辑
public:
    static RpcQueue& Instance(){ static RpcQueue T; return T; }
    RpcQueue() { LoadRpcCsv(); }

    void Insert(Typ* pObj, const void* pData, uint size)
    {
        _queue.push(std::make_pair(pObj, new NetPack(pData, size)));
    }
    void Update() //主循环，每帧调一次
    {
        RpcPair data;
        if (_queue.pop(data))
        {
            _Handle(data.first, *data.second);

            delete data.second;
        }
    }
    void _Handle(Typ* pObj, NetPack& buf)
    {
        uint16 opCode = buf.GetOpcode();

        auto it = Typ::_rpc.find(opCode);
        if (it != Typ::_rpc.end()) {
            NetPack& backBuffer = pObj->BackBuffer();
            backBuffer.ClearBody();
            backBuffer.SetOpCode(buf.GetOpcode());
            backBuffer.SetFromType(buf.GetFromType());

            (pObj->*(it->second))(buf);

            if (backBuffer.BodyBytes()) pObj->SendMsg(backBuffer);
        }
        else
        {
            auto it = _response.find(opCode);
            assert(it != _response.end());
            if (it != _response.end()) it->second(buf);
        }
    }
    void RegistResponse(int opCode, const ParseRpcParam& func)
    {
        assert(Typ::_rpc.find(opCode) == Typ::_rpc.end());

        _response.insert(make_pair(opCode, func));
    }
    int RpcNameToId(const char* name)
    {
        auto it = _rpc_table.find(name);
        if (it == _rpc_table.end()) {
            assert(0);
            return 0;
        }
        return it->second;
    }
    int _CallRpc(const char* name, const ParseRpcParam& func, const SendMsgFunc& doSend)
    {
        int opCodeId = RpcNameToId(name);
        assert(opCodeId > 0);
        static NetPack msg(0);
        msg.ClearBody();
        msg.SetOpCode(opCodeId);
        func(msg);
        doSend(msg);
        return opCodeId;
    }

private:
    std::map<std::string, int> _rpc_table;
    void LoadRpcCsv()
    {
        csv::Parser file = csv::Parser("../data/csv/rpc.csv");
        uint cnt = file.rowCount();
        for (uint i = 0; i < cnt; ++i) {
            csv::Row& row = file[i];
            _rpc_table[row["name"]] = atoi(row["id"].c_str());
        }
    }
};
#define sRpcClient RpcQueue<Player>::Instance()
#define sRpcCross RpcQueue<CrossAgent>::Instance()
